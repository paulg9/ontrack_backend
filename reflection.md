This project was moderately difficult for me because I do not have a ton of web development experience, especially on the frontend side, but I liked that the assignment let me build something that actually felt useful. Once I had the idea for the app, the overall direction made sense and I could see how the concepts from class mapped to what I was building. The freedom to make my own app was the part that went the best.
The main mistake I made was trying to “one shot” things with Cursor. When I gave it a huge task and let it generate the whole frontend at once, the code was harder to debug and I spent more time chasing small mismatches between the backend and the UI. What worked way better was a step-by-step approach: have the tool generate one component or one flow, test it, show it the exact error, and then fix from there. That pattern made it easier to keep the code aligned with what I actually wanted. If I did this again, I would plan from the start to work in smaller units instead of trying to auto-build the whole app.
On the backend, I used the Context tool pretty systematically. My recipe was: show it my concept spec and background docs so it had the right vocabulary, ask it to review and restate the concept, have it outline the data and methods with good inline documentation, and then ask it to fill in the functions and generate tests. Doing it in that order kept the code close to the spec and saved me from writing a lot of boilerplate. On the frontend, I used the agentic coding tool: I generated the frontend against the existing API, ran it, pasted the errors back in, and let it adjust. Sometimes the better fix was actually in the backend, so I let the tool influence that too. After it was working functionally, I asked it to make design tweaks. For 4c, I used the agentic coding tool to help implement the syncs once I decided the big picture of what I wanted, then used it to fix the front end as well.
In terms of skills, I definitely got better at thinking about app structure end to end: concepts to backend to frontend to deployment. I also got more practice with UI/user journeys, which I do not do as much in my research projects. I still want to get better at testing. Overall, my conclusion about LLMs in software development is that they are very useful as long as you do not dump everything on them at once. If you give them the right context, keep the task small, and stay in the loop, they make you faster. If you try to make them build the whole thing in one shot, you spend your time fixing their guesses instead of shipping.

