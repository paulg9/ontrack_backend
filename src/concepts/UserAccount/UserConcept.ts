import { Collection, Db } from "npm:mongodb";
import { Empty, ID } from "@utils/types.ts";
import { freshID } from "@utils/database.ts"; // Required for generating new entity IDs

// Declare collection prefix, using the concept name for clarity in the database
const PREFIX = "UserAccount" + ".";

// Define internal ID types for the entities managed by this concept.
// These are branded string types for better type safety and clarity, consistent with `ID`.
type User = ID;
type ShareLink = ID;

// Define specific types for data fields that aren't primitive strings/numbers.
// TimeOfDay: Represented as a string, e.g., "14:30" for 2:30 PM.
type TimeOfDay = string;
// DateTime: Represented using the standard JavaScript Date object for easy manipulation and storage.
type DateTime = Date;

/**
 * Interface representing the structure of a 'User' document in the MongoDB collection.
 * Corresponds to "a set of Users with ..." in the concept state.
 */
interface UserDoc {
  _id: User; // The unique identifier for the user, generated by freshID()
  username: string; // The user's chosen username
  passwordHash: string; // A hashed version of the user's password for security
  reminderTime: TimeOfDay | null; // The user's preferred reminder time, nullable if not set
  shareLinks: ShareLink[]; // An array of IDs of ShareLink entities owned by this user
}

/**
 * Interface representing the structure of a 'ShareLink' document in the MongoDB collection.
 * Corresponds to "a set of ShareLinks with ..." in the concept state.
 */
interface ShareLinkDoc {
  _id: ShareLink; // The unique identifier for the share link, generated by freshID()
  token: string; // The actual token string that users will use for access
  expiry: DateTime; // The date and time when this share link expires
  owner: User; // The ID of the user who created this share link
}

/**
 * **concept** UserAccount
 *
 * **purpose** To enable the creation, management, and personalization of a user's account within the application.
 *
 * **principle** An athlete registers for an account, personalizes their notification reminder time,
 * and can generate or revoke temporary share links to their data, all managed through their account.
 */
export default class UserAccountConcept {
  // MongoDB collection for storing User documents
  users: Collection<UserDoc>;
  // MongoDB collection for storing ShareLink documents
  shareLinks: Collection<ShareLinkDoc>;

  /**
   * Constructor for the UserAccountConcept.
   * Initializes the MongoDB collections used by this concept.
   * @param db The MongoDB database instance to use for collections.
   */
  constructor(private readonly db: Db) {
    this.users = this.db.collection(PREFIX + "users");
    this.shareLinks = this.db.collection(PREFIX + "shareLinks");
    
    // Create unique index on username field to enforce uniqueness at database level
    this.users.createIndex({ username: 1 }, { unique: true }).catch(() => {
      // Index creation might fail if it already exists, which is fine
    });
  }

  /**
   * `register (username: String, password: String) : (user: User)`
   *
   * **requires** `username` is not already taken
   *
   * **effects** creates a new `User`, assigns the provided `username` and `passwordHash` (of the `password`),
   * sets `reminderTime` to a default value (e.g., null), and initializes `shareLinks` as an empty set.
   *
   * @param params An object containing the username and password for registration.
   * @returns A Promise resolving to an object with the new user's ID on success, or an error message.
   */
  async register(
    { username, password }: { username: string; password: string; },
  ): Promise<{ user: User; } | { error: string; }> {
    // DANGER: Plaintext password. In a real app, use a strong hashing library like bcrypt.
    const passwordHash = password; // Placeholder for actual hash

    const newUserId = freshID();
    const newUser: UserDoc = {
      _id: newUserId,
      username: username,
      passwordHash: passwordHash,
      reminderTime: null, // Default value
      shareLinks: [], // Initialize as empty set
    };

    try {
      await this.users.insertOne(newUser);
      return { user: newUserId };
    } catch (error: any) {
      // Handle duplicate key error (MongoDB error code 11000)
      if (error.code === 11000) {
        return { error: "Username already taken" };
      }
      // Re-throw other errors
      throw error;
    }
  }

  /**
   * `setReminderTime (user: User, time: TimeOfDay)`
   *
   * **requires** `user` exists
   *
   * **effects** sets `user.reminderTime := time`
   *
   * @param params An object containing the user's ID and the new reminder time.
   * @returns A Promise resolving to an empty object on success, or an error message.
   */
  async setReminderTime(
    { user, time }: { user: User; time: TimeOfDay; },
  ): Promise<Empty | { error: string; }> {
    // Check if user exists
    const existingUser = await this.users.findOne({ _id: user });
    if (!existingUser) {
      return { error: "User not found" };
    }

    // Update the user's reminderTime
    await this.users.updateOne(
      { _id: user },
      { $set: { reminderTime: time } },
    );

    return {};
  }

  /**
   * `createShareLink (owner: User, ttlSeconds: Number) : (token: String)`
   *
   * **requires** `owner` exists
   *
   * **effects** creates a new `ShareLink` with a randomly generated `token`,
   * sets `expiry = now + ttlSeconds`, associates `owner` with the provided `User`,
   * and adds this `ShareLink` to `owner.shareLinks`.
   *
   * @param params An object containing the owner's ID and the time-to-live for the link in seconds.
   * @returns A Promise resolving to an object with the generated token on success, or an error message.
   */
  async createShareLink(
    { owner, ttlSeconds }: { owner: User; ttlSeconds: number; },
  ): Promise<{ token: string; } | { error: string; }> {
    // Check if owner exists
    const existingUser = await this.users.findOne({ _id: owner });
    if (!existingUser) {
      return { error: "Owner user not found" };
    }

    // Generate a random token string (e.g., UUID)
    const shareToken = crypto.randomUUID();

    // Calculate expiry time
    const expiryDate = new Date();
    expiryDate.setSeconds(expiryDate.getSeconds() + ttlSeconds);

    // Create a new ShareLink document
    const newShareLinkId = freshID();
    const newShareLink: ShareLinkDoc = {
      _id: newShareLinkId,
      token: shareToken,
      expiry: expiryDate,
      owner: owner,
    };

    // Insert the new ShareLink into the shareLinks collection
    await this.shareLinks.insertOne(newShareLink);

    // Add the new ShareLink's ID to the owner's shareLinks array in the users collection
    await this.users.updateOne(
      { _id: owner },
      { $push: { shareLinks: newShareLinkId } },
    );

    return { token: shareToken };
  }

  /**
   * `revokeShareLink (owner: User, token: String)`
   *
   * **requires** a `ShareLink` exists with the given `token` and its `owner` is the provided `owner`
   *
   * **effects** removes the `ShareLink` with the specified `token` from `owner.shareLinks`
   * and deletes the `ShareLink` itself.
   *
   * @param params An object containing the owner's ID and the token of the share link to revoke.
   * @returns A Promise resolving to an empty object on success, or an error message.
   */
  async revokeShareLink(
    { owner, token }: { owner: User; token: string; },
  ): Promise<Empty | { error: string; }> {
    // 1. Find and delete the ShareLink in one atomic operation
    const result = await this.shareLinks.findOneAndDelete({ 
      token: token,
      owner: owner // Check for token AND owner at the database level
    });

    // The result of findOneAndDelete is the document that was deleted, or null if nothing was found.
    const shareLinkToRevoke = result;

    if (!shareLinkToRevoke) {
      // This error covers all failure cases: token doesn't exist, or it doesn't belong to this owner.
      // This is more secure as it doesn't reveal which case it was.
      return { error: "ShareLink not found or you do not have permission to revoke it" };
    }

    // 2. If deletion was successful, remove the link from the user's document.
    await this.users.updateOne(
      { _id: owner },
      { $pull: { shareLinks: shareLinkToRevoke._id } },
    );

    return {};
  }
}

