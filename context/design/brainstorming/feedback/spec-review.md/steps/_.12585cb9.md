---
timestamp: 'Thu Oct 23 2025 22:55:29 GMT-0400 (Eastern Daylight Time)'
parent: '[[../20251023_225529.352b0b90.md]]'
content_id: 12585cb93fac2aecc8918868cd8e02856b1211c21431d0284ff112da10971e8d
---

# Concept Design Background

Concept design organizes software into concepts, which are independent and familiar units of functionality with a single purpose. A concept specification contains:

* **concept**: a descriptive name balancing generality of use and appropriate specificity
* **purpose**: the reason for why this concept exists, and what it enables
* **principle**: a motivating scenario that establishes how the concept achieves its purpose
* **state**: a simple state modeling language meant to capture the basic relationships between the necessary information
* **actions**: a set of events that (largely) mutate the state or update represented information, written as a set of pre/postconditions: what the action **requires** in order to occur, and what **effects** it has

Concepts are uniquely motivated by the fact that they are:

1. Completely independent of one another in terms of dependencies and state.
2. Work off generic parameters, and cannot know about specific types.
3. Strongly grounded in a user-relevant purpose, and not just a structure for software.

## Concept: Feedback

**Purpose** Compute and deliver habit-forming feedback and reminders from check-ins

**Principle** As the athlete logs check-ins, the system computes streaks and completion rates; at a configured reminder time, if the day’s check-in is missing, send a reminder

**State**

* a set of Summaries with
  * owner User
  * streakCount Number
  * completion7d Ratio
* a set of Messages with
  * owner User
  * timestamp DateTime
  * kind {reminder, motivation, summary}
  * text String

**Actions**

* recompute (owner: User, today: Date) : (summary: Summary)
  * requires owner exists
  * effects upserts owner’s Summary with streakCount and completion7d derived from recent CheckIns

* recordMessage (owner: User, kind: Enum, text: String) : (msg: Message)
  * requires owner exists
  * effects appends a new Message for audit/tracking

* sendReminder (owner: User)
  * requires owner exists; now.time ≥ owner.reminderTime; no CheckIn exists for (owner, today)
  * effects delivers a reminder (out-of-band) and records a reminder Message

**Syncs**

* computeFeedback
  * When CheckIn.submit (owner, date)
  * Where owner, date
  * Then Feedback.recompute (owner, today: date)

* motivateOnImprovement
  * When Feedback.recompute (owner, today) : (summary)
  * Where summary.streakCount
  * Then Feedback.recordMessage (owner, kind: motivation, text: "Nice work — streak " + summary.streakCount + " days!")

* dailyReminder
  * When time.reaches (User.reminderTime)
  * Where user: User
  * Then Feedback.sendReminder (owner: user)

* shareOpen
  * When User.createShareLink (user) : (token)
  * Where token
  * Then Feedback.recordMessage (owner: user, kind: summary, text: "Share link created; weekly summary visible via link.")

* weeklySummary
  * When calendar.endsWeek () : (weekEndDate)
  * Where user: User
  * Then Feedback.recompute (owner: user, today: weekEndDate)
  * Then Feedback.recordMessage (owner: user, kind: summary, text: "Weekly: " + Feedback.Summary(owner).completion7d\*100 + "% complete.")
